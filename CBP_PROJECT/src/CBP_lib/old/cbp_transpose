!SVD Decomposition 
!A must be dispathced in blocks " basic descriptor or matmul descriptors are ok" 
!Also out from transpose or adjoint

!subroutine cbp_SVD_GulobReinsch_bad(U0, descriptorU, A, descriptorA, dimA, V0, descriptorV, ngpu, rank, nprocs) 

	CTYPE , dimension(:,:) :: A, U0,V0
	CTYPE , dimension(:,:), allocatable :: Ttemp ,A0,U, V
	integer, dimension(4) :: descriptorA, descriptorU, descriptorV
	
	CTYPE, dimension(2) :: eval , tempv
	CTYPE, dimension(2,2) :: evec , subAAT
	CTYPE :: blueM, blueDET, cosj , sinj 
	integer :: ii  , it , lr, lc, startdo, finishdo
	integer :: rank, nprocs, ierr, ngpu, cntr
	integer, dimension(4) :: svddesc
	integer, dimension(2) :: ldiag, dimA
	integer :: side, oddeven, maxit,pivot,workonpivot
	double precision :: e, sens 
	
	!Test, eigenvalues
	CTYPE, dimension(2,2) :: test
	
	e = 1e-11
	sens = 1e-11
	
	cntr = 0 
	
	! A is a upper bidiagonal matrix, redispatch it as blocks overlapping on the diagonal
	 !  with a 2x2 overlap on the diagonal 
	
	ldiag = ceiling(real(min(dimA(1), dimA(2)))/ real(nprocs))  
		
	svddesc = [ ldiag(1)+2 , ldiag(2)+2 , ldiag(1)*rank+1, ldiag(2)*rank+1 ]
	
	if (rank .eq. nprocs-1)  then 	
		svddesc(1:2) = minval(dimA) - ldiag*rank 
		if ( dimA(2) .gt. dimA(1) ) then
			svddesc(2) = svddesc(2) +1 ! last bidiagonal element 
		end if  
	end if 
	print*, svddesc
	allocate(U(maxval(svddesc(1:2)),maxval(svddesc(1:2))))
	allocate(V(maxval(svddesc(1:2)),maxval(svddesc(1:2))))
	allocate(Ttemp(maxval(svddesc(1:2)),maxval(svddesc(1:2))))
	
	U = CTYPE0
	do ii = 1, maxval(svddesc(1:2))
		U(ii,ii) = CTYPE1
	end do 
	V = CTYPE0
	do ii = 1, maxval(svddesc(1:2))
		V(ii,ii) = CTYPE1
	end do 
	
	allocate(A0(size(A, dim=1) ,size(A, dim=2)))
	call cbp_redispatch(A,descriptorA, svddesc,rank,nprocs)
	
	!do ii = 1, dimA(1) 
    	!	print  "(*('('sf6.2xspf6.2x'i)':x))", A(ii, :) 
    	!end do 
    	!print*, " " 
	A0 = A
	!Proceed with the algorithm decomposition
	
	!4 different cases , left or rigth multiplication, and odd idx of even idx
	pivot = 1 !point to perform the first jacobi rotation to mess up the bidiagonal form.
	it = 0 !oddeven is odd when it is odd, even when it is even
	do while (.TRUE.) !svd complete
	
		maxit = (it+2)/2
		oddeven =  1-mod(it,4)/2 !first it is odd, second is odd, third even , 4th even , 5 odd.. 
		side = mod(it,2) !zero is right , 1 is left 
		
		it = it + 1	! first iteration on the right , and odd the second then switch 
		 	       
		!print*, "side", side , "oddeven", oddeven , "pivot", pivot
		
		if (side .eq. 0 ) then 
			
			Ttemp = CTYPE0
			do ii = 1, maxval(svddesc(1:2))
				Ttemp(ii,ii) = CTYPE1
			end do 
			
			if (svddesc(3) .le. pivot .and. sum(svddesc(1:3:2))-1 .ge. pivot ) then 
				
				lr = pivot - svddesc(3) +1
				lc = pivot - svddesc(4) +1
				
				!if (pivot .eq. dimA(2)-1) then 
				!print*, abs(A(lr+1,lc)),abs(A(lr,lc+2)), abs(A(lr,lc+1)) , pivot , cntr
				!end if 
				if ((lr .ne.  svddesc(1) .and. abs(A(lr+1,lc)) .lt. e ) .and. & 
				   (lc .ne.  svddesc(2) .and. sum(abs(A(lr,lc+1:))) .lt. 2*e )) then 
					print*, abs(A(lr+1,lc)),abs(A(lr,lc+2)), abs(A(lr,lc+1)) , pivot , cntr, dimA**3
					print*, " " 
					
					!do ii = 1, dimA(1) 
				    	!	print  "(*('('sf6.2xspf6.2x'i)':x))", A(ii, :) 
				    	!end do 
				    	!print*, " " 
					if (pivot.eq.dimA(2)-1) then
						
						exit 
					end if  
					pivot = pivot+1
					
				end if  
				
			end if 
	
			!start : if block start w even idx, but globally i want to perform odd op 1 + abs(0-1) = 2
			!4 cases : even-even or odd-odd start = 1, even-odd, odd-even start = 2 
			
			workonpivot = pivot_condition_svd(pivot, svddesc, rank, nprocs) ! Check which process works on & 
							     !the pivot but not if it is the iteration to work on it 
			!start of the o cycle
			!pivot-1 is the number of pivot set to 0 globally.we start from pivot locally
			!Or if the process chunk starts after pivot we start from its start.
			!If a process contains the pivot we skip the pivot and work on that outside the cycle
			 
			if (rank .gt. 0 ) then   
			startdo  = max(pivot - svddesc(4) +1 + abs(mod(pivot,2)-oddeven), & !1 real start. check if odd iteration or even iteration
			                2 + abs(mod(svddesc(4)+1,2)-oddeven)) !I can not work on the first with this iteration unless it is the pivot
			                				       ! the process w rank-1 will take care of that 
			else 
			startdo  = max(pivot - svddesc(4) +1 + abs(mod(pivot,2)-oddeven), & !1 real start. check if odd iteration or even iteration
			                1 + abs(mod(svddesc(4),2)-oddeven))	
			end if 
			
			finishdo = min(maxit - svddesc(4) +1 , svddesc(2)-1 ) !svddesc(2)-1 because i can still annihilate that element
									       !since the we zero the upperight element w respect to the do variable   
									       ! No problem for the process with the last chunk (Hope so..)
			!-----------------------------------------------------------------------------------
			
			!print*, startdo , pivot - svddesc(4) +1
			!If i really have to work on the pivot skip it and do it outside the do loop
			if (startdo .eq. pivot - svddesc(4) +1 .and. workonpivot.eq.1) then 
				startdo = startdo+2
			
				!perform jacobi rotation instead of the first odd V
			!compute eigenvalues and eigenvectors of pivot 2x2 matrix 
			! ref https://www.youtube.com/watch?v=e50Bj7jn9IQ&t=642s&ab_channel=3Blue1Brown
				cntr = cntr+1
				
				!Coordinates of the element on the side of the bidiagonal element to "reduce"
				lr = pivot - svddesc(3) +1
				lc = pivot - svddesc(4) +1
				
				if (pivot.ne.dimA(2) -1) then 
				
					!print*, "G", lr
					if ( abs(A(lr,lc+1)) .lt. e ) then !if pivot element is small do nothing 
						Ttemp(lr, lc:lc+1) = [CTYPE1,CTYPE0]
						Ttemp(lr+1, lc:lc+1) = [CTYPE0,CTYPE1]
					else 
						subAAT = matmul(transpose(conjg(A(lr:lr+1,lc:lc+1))),A(lr:lr+1,lc:lc+1))
						
						blueM = (subAAT(1,1) + subAAT(2,2)) / 2.d0
						bluedet = subAAT(1,1)*subAAT(2,2)-subAAT(2,1)*subAAT(1,2)
						eval = [ blueM - sqrt(blueM**2 - blueDET) , blueM + sqrt(blueM**2 - blueDET) ] 
						
						evec(:,1) =  [ -subAAT(lr,lc+1) , subAAT(lr,lc)-eval(1) ]
						evec(:,2) =  [ -subAAT(lr,lc+1) , subAAT(lr,lc)-eval(2) ]
						
						
						evec(:,1) = evec(:,1)/abs(sqrt(dot_product(evec(:,1),evec(:,1))))
						evec(:,2) = evec(:,2)/abs(sqrt(dot_product(evec(:,2),evec(:,2))))
						
						if (abs(eval(1)-subAAT(2,2)) .lt. abs(eval(2)-subAAT(2,2)) ) then 
							!print*, "V", ii 
							tempv = [ A(lr,lc)**2-eval(1),A(lr,lc)*A(lr,lc+1) ]
						
							
							!Ttemp(lr, lc:lc+1) = [evec(1,1), evec(2,1)]
							!Ttemp(lr+1, lc:lc+1)= [-evec(2,1),conjg(evec(1,1))]
						else 
							tempv = [ A(lr,lc)**2-eval(2),A(lr,lc)*A(lr,lc+1) ]
							!Ttemp(lr, lc:lc+1) = [evec(1,2), evec(2,2)]
							!Ttemp(lr+1, lc:lc+1)= [-evec(2,2),conjg(evec(1,2))]
						end if 
						
						if ( abs(sqrt(dot_product(tempv, tempv))) .gt. sens) then 
							cosj = conjg(tempv(1))/ abs(sqrt(dot_product(tempv, tempv)))
							sinj = -(tempv(2)) / abs(sqrt(dot_product(tempv,tempv)))
						else 
							cosj = CTYPE1
							sinj = CTYPE0 
						end if 
						
						Ttemp(lr, lc:lc+1) = [conjg(cosj),conjg(sinj)]
			  			Ttemp(lr+1,   lc:lc+1) = [-sinj,cosj]
			  			
			  		end if 
					
				else 
					if ( abs(sqrt(dot_product(A(lr,lc-1:lc),A(lr,lc-1:lc)))) .gt. sens) then 
						cosj = A(lr,lc) / abs(sqrt(dot_product(A(lr,lc:lc+1),A(lr,lc:lc+1))))
						sinj = -conjg(A(lr,lc+1)) / abs(sqrt(dot_product(A(lr,lc:lc+1),A(lr,lc:lc+1))))
					else 
						cosj = CTYPE1
						sinj = CTYPE0 
					end if
					
					Ttemp(lr, lc:lc+1) = [conjg(cosj),conjg(sinj)]
			  		Ttemp(lr+1,   lc:lc+1) = [-sinj,cosj]  
					
				end if 
					!Test Eigenvalues
					!test = matmul(subAAT,evec) 
					!evec = transpose(conjg(evec))
					!test = matmul(evec,test) 
					!print*, test(1,:)
					!print*, test(2,:)
					!print*, eval
					!Ttemp(lr:lr+1, lc:lc+1) = evec
					
				
			end if
			!-----------------------------------------------------------------------------------
			
			do ii = startdo, finishdo, 2 !start index for the 2x2 rotation  
			!limits as columns because multiplication on the right need limit defined by cols
				
				!coordinates of local element to annihilate
				lr = ii-1
				lc = ii+1
				
				!print*, "V", ii 
				if ( abs(sqrt(dot_product(A(lr,lc-1:lc),A(lr,lc-1:lc)))) .gt. sens) then 
					cosj = A(lr,lc-1) / abs(sqrt(dot_product(A(lr,lc-1:lc),A(lr,lc-1:lc))))
					sinj = -conjg(A(lr,lc)) / abs(sqrt(dot_product(A(lr,lc-1:lc),A(lr,lc-1:lc))))
				else 
					cosj = CTYPE1
					sinj = CTYPE0 
				end if 
			  	
			  	Ttemp(ii, ii:ii+1) = [conjg(cosj),conjg(sinj)]
			  	Ttemp(ii+1, ii:ii+1) = [-sinj,cosj]
			
			end do 
			!Update 
			A = matmul(A,Ttemp(:svddesc(2),:svddesc(2))) 
			V(:svddesc(2),:svddesc(2)) = matmul(V(:svddesc(2),:svddesc(2)), Ttemp(:svddesc(2),:svddesc(2)))
			!print*, "TTEMP"
			!do ii = 1, svddesc(2) 
    			!print  "(*('('sf6.2xspf6.2x'i)':x))", Ttemp(ii, :) 
    			!end do 
    			!print*, " " 
			
			!print*, "A"
			!do ii = 1, dimA(1) 
    			!	print  "(*('('sf6.2xspf6.2x'i)':x))", A(ii, :) 
    			!end do 
    			!print*, " " 
			
			
			!Exchange of the shared 2x2 block
			if (rank.lt. nprocs-1) then 
				print*, "send"
				call MPI_SEND(A( svddesc(1)-1:svddesc(1), svddesc(2)-1:svddesc(2)),4, MPI_CTYPE, rank+1, 2*rank, MPI_COMM_WORLD, ierr )
			end if 
			if (rank.gt. 0) then 
				print*, "recv"
				call MPI_RECV(A(1:2,1:2),4, MPI_CTYPE, rank-1, 2*rank, MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierr )
				
				if (abs(A(1,2)) .lt. e ) then 
					!if it gets the offdiagonal entry equal zero, it means that it's turn of performing 
					!jacobi rotation it is near.  
					pivot = svddesc(3)
				end if
				 
			end if 
			
		else if (side.eq.1) then 
		        
		        Ttemp = CTYPE0
			do ii = 1, maxval(svddesc(1:2))
				Ttemp(ii,ii) = CTYPE1
			end do 
			!print*, 1 + abs(mod(svddesc(3),2)-oddeven), min ( maxit - svddesc(3) +1 , svddesc(1)-1 )
			
			do ii = 1 + abs(mod(svddesc(3),2)-oddeven) , min ( maxit - svddesc(3) +1, svddesc(1)-1 )  , 2 !start index for the 2x2 rotation  
			!limits as columns because multiplication on the right need limit defined by cols

				lr = ii
				lc = ii
				!print*, "U", lr
				if ( abs(sqrt(dot_product(A(lr,lc:lc+1),A(lr,lc:lc+1)))) .gt. sens) then 
					cosj = A(lr,lc) / abs(sqrt(dot_product(A(lr:lr+1,lc),A(lr:lr+1,lc))))
					sinj = A(lr+1,lc) / abs(sqrt(dot_product(A(lr:lr+1,lc),A(lr:lr+1,lc))))
				else 
					cosj = CTYPE1
					sinj = CTYPE0 
				end if 
			  	!print*, "a" , A(lr,lc+1) *conjg(cosj) , conjg(sinj)*A(lr+1,lc+1) 
			  	!print*,  "b" ,A(lr,lc) *sinj , cosj*A(lr+1,lc)
			  	Ttemp(lr, lc:lc+1) = [conjg(cosj),conjg(sinj)]
			  	Ttemp(lr+1,   lc:lc+1) = [-sinj,cosj]
			
			end do 
			
			A = matmul(Ttemp(:svddesc(1),:svddesc(1)),A) 
			U(:svddesc(1),:svddesc(1)) = matmul(Ttemp(:svddesc(1),:svddesc(1)),U(:svddesc(1),:svddesc(1))) 
			!print*, "A"
			!do ii = 1, dimA(1) 
    			!	print  "(*('('sf6.2xspf6.2x'i)':x))", A(ii, :) 
    			!end do 
    			!print*, " " 
			 
    			
    			!do ii = 1, svddesc(2) 
    			!print  "(*('('sf6.2xspf6.2x'i)':x))", Ttemp(ii, :) 
    			!end do 
    			!print*, " " 
			
			!Exchange of the shared 2x2 block
			if (rank.gt. 0) then 
				print*, "send"
				call MPI_SEND(A( svddesc(1)-1:svddesc(1), svddesc(2)-1:svddesc(2)),4, & 
					MPI_CTYPE, rank-1, 2*rank+1, MPI_COMM_WORLD, ierr )
			end if 
			if (rank.lt. nprocs-1) then 
				print*, "recv"
				call MPI_RECV(A(1:2,1:2),4, MPI_CTYPE, rank+1, 2*rank+1, & 
					MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierr )
			end if 	
		
		end if 
		
	
	end do 
	Ttemp = CTYPE0
	do ii = 1, maxval(svddesc(1:2))
		Ttemp(ii,ii) = CTYPE1
	end do 
	print*, sum ( matmul(matmul(transpose(conjg(U)),A),transpose(conjg(V)))- A0)
	
	
end subroutine
